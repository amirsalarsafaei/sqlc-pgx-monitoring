// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify
{{- if (index .TemplateData "boilerplate-file") }}
{{ index .TemplateData "boilerplate-file" | readFile }}
{{- end }}
{{- if (index .TemplateData "mock-build-tags") }}

//go:build {{ index .TemplateData "mock-build-tags" }}
{{- end }}

package {{.PkgName}}

import (
{{- range .Imports}}
	{{ .ImportStatement }}
{{- end}}
    mock "github.com/stretchr/testify/mock"

	_metricotelembedded "go.opentelemetry.io/otel/metric/embedded"
	_traceotelembedded "go.opentelemetry.io/otel/trace/embedded"
)

{{/* CREATE CONSTRUCTOR */}}

{{- range $i, $mock := .Interfaces }} {{/* START MOCK RANGE */}}
{{ $new := "New" }}
{{ if firstIsLower .StructName }}
{{ $new = "new" }}
{{- end }}
{{- $constructorName := printf "%s%s" $new (.StructName | firstUpper) }}

// {{ $constructorName }} creates a new instance of {{ .StructName }}. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func {{ $constructorName }}{{ $mock.TypeConstraint }} (t interface {
	mock.TestingT
	Cleanup(func())
}) *{{ .StructName }}{{ $mock.TypeInstantiation }} {
	mock := &{{ .StructName }}{{ $mock.TypeInstantiation }}{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}


// {{ .StructName }} is an autogenerated mock type for the {{ .Name }} type
type {{ .StructName }}{{ $mock.TypeConstraint }} struct {
	mock.Mock
	{{- if ne $mock.Name "MeterProvider" }}
	_metricotelembedded.Meter
	{{- end }}
	_metricotelembedded.MeterProvider
	_traceotelembedded.Span
	{{- if ne $mock.Name "TracerProvider" }}
	_traceotelembedded.Tracer
	{{- end }}
	{{- if ne $mock.Name "Span" }}
	_traceotelembedded.TracerProvider
	{{- end}}
	{{- if ne $mock.Name "Meter"}}
	_metricotelembedded.Float64Histogram
	{{- end}}
}

type {{.StructName}}_Expecter{{ $mock.TypeConstraint }} struct {
	mock *mock.Mock
}

{{- $expecterNameInstantiated := printf "%s_Expecter%s" .StructName ($mock.TypeInstantiation) }}

func (_m *{{.StructName}}{{ $mock.TypeInstantiation }}) EXPECT() *{{ $expecterNameInstantiated }} {
	return &{{ $expecterNameInstantiated }}{mock: &_m.Mock}
}

{{/* RANGE OVER ALL METHODS */}}
{{- range $methodIdx, $method := .Methods }} {{/* START METHOD RANGE */}}

// {{ $method.Name }} provides a mock function for the type {{ $mock.StructName }}
func (_mock *{{$mock.StructName}}{{ $mock.TypeInstantiation }}) {{$method.Name}}({{$method.ArgList}}) {{$method.ReturnArgTypeList}} {
	{{- $calledString := "" }}
{{- if or
	(eq (len $method.ArgList) 0)
	(not $method.IsVariadic)
	(not (index $mock.TemplateData "unroll-variadic"))
}} {{/* START PREAMBLE */}}
	{{- if and
		($method.IsVariadic)
		(not (index $mock.TemplateData "unroll-variadic"))
	}}

	{{- if ne (len $method.Returns) 0}}
	var tmpRet mock.Arguments
	{{- $calledString = "tmpRet" }}
	{{- else }}
	{{- $calledString = "" }}
	{{- end }}

	{{- $lastParam := index $method.Params (len $method.Params | add -1 )}}
	if len({{ $lastParam.Var.Name }}) > 0 {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	} else {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallListSlice 0 (len $method.Params | add -1 )}}{{- else }}{{ $method.ArgCallListSliceNoEllipsis 0 (len $method.Params | add -1 )}}{{- end }})
	}
	{{- else }}
	{{- $calledString = printf "_mock.Called(%s)" $method.ArgCallList }}
	{{- end }}
{{- else }}
	{{- $lastParam := (index $method.Params (len $method.Params | add -1)) }}
	{{- $variadicArgsName := $lastParam.Var.Name }}
	{{- $strippedTypeString := trimPrefix "..." $lastParam.TypeStringEllipsis }}

	{{- if and (ne $strippedTypeString "interface{}") (ne $strippedTypeString "any") }}
	// {{ $strippedTypeString }}
	_va := make([]interface{}, len({{- $lastParam.Var.Name }}))
	for _i := range {{ $lastParam.Var.Name }} {
		_va[_i] = {{ $lastParam.Var.Name }}[_i]
	}
		{{- $variadicArgsName = "_va" }}
	{{- end }}
	var _ca []interface{}
	{{- if gt (len $method.Params) 1 }}
	_ca = append(_ca, {{ $method.ArgCallListSlice 0 (len $method.Params | add -1) }})
	{{- end }}
	_ca = append(_ca, {{ $variadicArgsName }}...)
	{{- $calledString = "_mock.Called(_ca...)" }}
{{- end }} {{/* END PREAMBLE */}}
	{{- if eq (len $method.Returns) 0 }}
	{{ $calledString }}
	{{- else }}
	{{- $retArgs := $method.Scope.AllocateName "ret" }}
	{{ $retArgs }} := {{ $calledString }}

	if len({{ $retArgs }}) == 0 {
		panic("no return value specified for {{$method.Name}}")
	}

		{{ range $retIdx, $ret := $method.Returns }}
	var r{{ $retIdx }} {{ (index $method.Returns $retIdx).TypeString }}
		{{- end }}

		{{- if gt (len $method.Returns) 1 }}
	if returnFunc, ok := {{ $retArgs }}.Get(0).(func{{ $method.SignatureNoName }}); ok {
		return returnFunc({{ $method.ArgCallList }})
	}
		{{- end }}

		{{- range $retIdx, $ret := $method.Returns }} {{/* START RETURN RANGE */}}
	if returnFunc, ok := {{ $retArgs }}.Get({{ $retIdx }}).(func({{$method.ArgTypeListEllipsis }}) {{ (index $method.Returns $retIdx).TypeString }}); ok {
		r{{ $retIdx }} = returnFunc({{ $method.ArgCallList }})
	} else {
		{{- if eq "error" (index $method.Returns $retIdx).TypeString }}
		r{{ $retIdx }} = {{ $retArgs }}.Error({{ $retIdx }})
		{{- else if (index $method.Returns $retIdx).Var.Nillable }}
		if {{ $retArgs }}.Get({{ $retIdx }}) != nil {
			r{{ $retIdx }} = {{ $retArgs }}.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		}
		{{- else }}
		r{{ $retIdx }} = {{ $retArgs }}.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		{{- end }}
	}
		{{- end }} {{/* END RETURN RANGE */}}
	{{- end }}
	return {{ range $retIdx, $ret := $method.Returns }}r{{ $retIdx }}{{ if ne $retIdx (len $method.Returns | add -1) }}, {{ end }}{{ end }}
}

{{/* CREATE EXPECTER METHOD */}}
{{- $ExpecterCallNameInstantiated := printf "%s_%s_Call%s" $mock.StructName $method.Name ($mock.TypeInstantiation) }}
{{- $ExpecterCallNameConstraint := printf "%s_%s_Call%s" $mock.StructName $method.Name ($mock.TypeConstraint) }}

// {{ $mock.StructName }}_{{ $method.Name }}_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method '{{ $method.Name }}'
type {{ $ExpecterCallNameConstraint }} struct {
	*mock.Call
}


// {{ $method.Name }} is a helper method to define mock.On call
{{- range $method.Params }}
//  - {{.Var.Name}} {{.TypeStringEllipsis}}
{{- end}}
func (_e *{{ $expecterNameInstantiated }}) {{ $method.Name }}({{ range $method.Params }}{{ .Var.Name }} {{ if .Variadic }}...{{end}}interface{}, {{ end }}) *{{ $ExpecterCallNameInstantiated }} {
	return &{{ $ExpecterCallNameInstantiated }}{Call: _e.mock.On("{{$method.Name}}",
			{{- if not $method.IsVariadic }}
				{{- range $method.Params}}{{.Var.Name}},{{end}}
			{{- else }}
				append([]interface{}{
					{{- range $i, $param := $method.Params }}
						{{- if (lt $i (len $method.Params | add -1 ))}} {{ $param.Var.Name }},
						{{- else }} }, {{ $param.Var.Name }}...
						{{- end }}
					{{- end}} )...
			{{- end }} )}
}

func (_c *{{ $ExpecterCallNameInstantiated }}) Run(run func({{ $method.ArgList }})) *{{ $ExpecterCallNameInstantiated }} {
	_c.Call.Run(func(args mock.Arguments) {
	{{- range $i, $param := $method.Params }}
		var arg{{ $i }} {{ $param.TypeString }}
		{{- if and $method.IsVariadic (eq ($i) (len $method.Params | add -1))}}

			{{- $variadicParam := index $method.Params (len $method.Params | add -1) }}
			{{- $nonVariadicParams := slice $method.Params 0 (len $method.Params | add -1 )}}

			{{- if index $mock.TemplateData "unroll-variadic" }}
		variadicArgs := make([]{{ $variadicParam.TypeStringVariadicUnderlying }}, len(args) - {{len $nonVariadicParams}})
		for i, a := range args[{{len $nonVariadicParams}}:] {
			if a != nil {
				variadicArgs[i] = a.({{ $variadicParam.TypeStringVariadicUnderlying }})
			}
		}
			{{- else }}
		var variadicArgs {{ $variadicParam.TypeString }}
		if len(args) > {{ len $nonVariadicParams }} {
			variadicArgs = args[{{ len $nonVariadicParams }}].({{ $variadicParam.TypeString }})
		}
			{{- end }}
		arg{{ $i }} = variadicArgs
		{{- else }}
		if args[{{ $i }}] != nil {
			arg{{ $i }} = args[{{ $i }}].({{ $param.TypeString }})
		}
		{{- end }}
	{{- end }}
		run(
			{{- range $i, $param := $method.Params }}
			{{- if and ($method.IsVariadic) (eq $i (len $method.Params | add -1 )) }}
			arg{{ $i }}...,
			{{- else }}
			arg{{ $i }},
			{{- end }}
			{{- end }}
		)
	})
	return _c
}

func (_c *{{ $ExpecterCallNameInstantiated }}) Return({{ $method.ReturnArgList }}) *{{ $ExpecterCallNameInstantiated }} {
	_c.Call.Return({{ $method.ReturnArgNameList }})
	return _c
}

func (_c *{{ $ExpecterCallNameInstantiated }}) RunAndReturn(run func({{ $method.ArgList }}){{ $method.ReturnArgTypeList }}) *{{ $ExpecterCallNameInstantiated }} {
{{- if eq (len $method.Returns) 0 }}
	_c.Run(run)
{{- else}}
	_c.Call.Return(run)
{{- end}}
	return _c
}
{{/* END TODO EXPECTER */}}
{{- end }} {{/* END METHOD RANGE */}}
{{- end }} {{/* END MOCK RANGE */}}

